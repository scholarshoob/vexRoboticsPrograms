#pragma config(Sensor, port2,  touchLED,       sensorVexIQ_LED)
#pragma config(Sensor, port3,  gyroSensor,     sensorVexIQ_Gyro)
#pragma config(Motor,  motor1,          leftDrive,     tmotorVexIQ, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motor4,          sideDrive,     tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor6,          rightDrive,    tmotorVexIQ, PIDControl, reversed, driveRight, encoder)
#pragma config(Motor,  motor9,          hookMotor,     tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor10,         rightArm,      tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor12,         leftArm,       tmotorVexIQ, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
* Function to calibrate gyro
*/
void iqCalibrateGyro()
{
	short count = 20;

	startGyroCalibration(gyroSensor, gyroCalibrateSamples512);
	// delay so calibrate flag can be set internally to the gyro
	wait1Msec(100);

	eraseDisplay();

	// wait for calibration to finish or 2 seconds, whichever is longer
	while(getGyroCalibrationFlag(gyroSensor) || (count-- > 0))
	{
		displayTextLine(1, "Calibrating... %02d", count/10);
		wait1Msec(100);
	}

	eraseDisplay();

	// reset so this is 0 heading
	resetGyro(gyroSensor);

	displayTextLine(2, "Gyro Value is: %d", getGyroHeading(gyroSensor));

}


void reOrient(float degrees, int sleepMSec){
	//Loop while the gyro sees a value less than 90 degrees.
  int currentDegree = getGyroDegrees(gyroSensor);

  if (abs(currentDegree - degrees) <= 1.0)
  	return;
  int reverseTurnFlag = 1;

	while(abs(currentDegree - degrees) > 5.0)
	{
		reverseTurnFlag = (currentDegree - degrees)>0? 1:-1;
		displayTextLine(3, "Gyro degree is: %d", currentDegree);
		displayTextLine(4, "Reverse flag: %d", reverseTurnFlag);
		//Set the motors to turn to the left at 25% speed.
		int degreeToTurn = 25 * reverseTurnFlag;
		setMotorSpeed(leftDrive, degreeToTurn);
		setMotorSpeed(rightDrive, degreeToTurn * -1);
		sleep(200);  //wait 1 second for the robot to come to a complete stop.
		//Specifically stop the motor at the end to force the robot to come to a "Holding" stop.
		setMotorSpeed(leftDrive, 0);
		setMotorSpeed(rightDrive, 0);
		// since getGyroDegrees can accumulate degrees over multiples of 360,
		// we can safely use remainder of 360
		currentDegree = getGyroDegrees(gyroSensor)%360;
	}
}

task main()
{
	iqCalibrateGyro();

	// this is to test to see if drive base can re-orient itself.
	while(true){
		reOrient(0, 100);
	  sleep(100);
	}
}
