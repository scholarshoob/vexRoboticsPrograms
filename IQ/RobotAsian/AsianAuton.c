#pragma config(Sensor, port2,  armBump,        sensorVexIQ_Touch)
#pragma config(Sensor, port3,  touchLED,       sensorVexIQ_LED)
#pragma config(Sensor, port11, storageUpBump,  sensorVexIQ_Touch)
#pragma config(Sensor, port12, storageDownBump, sensorVexIQ_Touch)
#pragma config(Motor,  motor1,          rightDrive,    tmotorVexIQ, PIDControl, driveRight, encoder)
#pragma config(Motor,  motor4,          armMotor,      tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor5,          clawMotor,     tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor6,          leftDrive,     tmotorVexIQ, PIDControl, reversed, driveLeft, encoder)
#pragma config(Motor,  motor7,          storageMotor,  tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor8,          intakeMotor,   tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor10,         intakeMotor,   tmotorNone, openLoop)
#pragma config(Motor,  motor11,         storageMotor,  tmotorNone, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

string open = "open";
string close = "close";

int right = 1;
int left = -1;

float gearRatio = 3.0/5.0;

//-- Robot move functions -- //
// Move Forward/Back
float tileDistanceinRotations = 0.9;

void moveRobotTiles(float tiles, int power){
	forward(tiles * tileDistanceinRotations, rotations, power);
}

void moveRobotMM(float mm, int power){
	if(mm > 0){
		forward((mm / 200.0) * gearRatio , rotations, power);
	}
	else if(mm < 0){
		backward((mm / 200.0) * gearRatio , rotations, power);
	}
}

// Turn Robot Right/Left
float turn1DegreeInRotations = 0.0055;

void turnRobotDegrees(int deg, int power, int direction){
	// 1 means turn right
	if(direction == 1){
		turnLeft(deg * turn1DegreeInRotations, rotations, power);
	}
	// 1 means turn left
	else if(direction == -1){
		turnRight(deg * turn1DegreeInRotations, rotations, power);
	}
}

// Robot limb functions
void claw(string action){
	float amountToMoveInRotations = 0.7;
	if(action == "open"){
		moveMotor(clawMotor, amountToMoveInRotations, rotations, 100);
	}
	else if(action == "close"){
		moveMotor(clawMotor, amountToMoveInRotations, rotations, -100);
	}
}

void moveArmInRotations(int distance, int power){
	moveMotor(armMotor, distance, rotations, -power);
}

// Scoring functions
void scoreGreenCubesInFrontOfLowPlatforms(int side){
	setTouchLEDColor(touchLED, colorRed);
	moveRobotMM(40, 25);
	turnRobotDegrees(22, 100, right * side);
	moveRobotMM(110, 100);
	moveRobotMM(30, 30);
	if(side == left){
		moveMotor(rightDrive, 0.35, rotations, 50);
		moveMotor(rightDrive, 0.2, rotations, 20);
	}
	else if(side == right){
		moveMotor(leftDrive, 0.35, rotations, 50);
		moveMotor(leftDrive, 0.2, rotations, 20);
	}
	moveRobotMM(125, 20);
	claw(close);
	moveArmInRotations(2 , 100);
	turnRobotDegrees(30, 100, right * side);
	moveRobotMM(380, 50);
	moveArmInRotations(1, -100);
	claw(open);
	moveRobotMM(-200, 100);
	setMotor(armMotor, 100);
	waitUntil(getBumperValue(armBump) == true);
	setMotor(armMotor, 0);
	return;
}

void scoreMiddleGreenCubeOnHighPlatform(int side){
	setTouchLEDColor(touchLED, colorRed);
	// Move forward away from wall
	moveRobotMM(40, 25);
	// Turn 45 degrees right
	turnRobotDegrees(60, 100, right * side);
	// Move forward to cube
	moveRobotMM(400, 100);
	turnRobotDegrees(15, 100, left * side);
	moveRobotMM(300, 20);
	// Pick up cubes
	claw(close);
	// Move forward to align with high platform
	moveArmInRotations(2, 100);
	// Turn to face high platform
	turnRobotDegrees(135, 100, right * side);
	// Move to high platform
	moveRobotMM(270, 50);
	// Open claw
	claw(open);
	moveRobotMM(-100, 100);
}

// Sensor Functions
void waitForLED(){
	waitUntil(getTouchLEDValue(touchLED) == true);
}

task main()
{
	setTouchLEDColor(touchLED, colorBlue);
	displayTextLine(line1, "Asian Robot Auton");
	displayTextLine(line2, "Made by Ky");
	displayTextLine(line3, "Hehe Shoob!");
	waitForLED();
	setMotor(armMotor, 100);
	waitUntil(getBumperValue(armBump) == true);
	setMotor(armMotor, 0);
	// Begin functions
	scoreGreenCubesInFrontOfLowPlatforms(left);
	setTouchLEDColor(touchLED, colorGreen);
	waitForLED();
	scoreGreenCubesInFrontOfLowPlatforms(right);
	setTouchLEDColor(touchLED, colorGreen);
	waitForLED();
	scoreMiddleGreenCubeOnHighPlatform(right);
	setTouchLEDColor(touchLED, colorGreen);
}
