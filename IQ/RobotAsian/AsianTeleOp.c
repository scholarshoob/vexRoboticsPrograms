#pragma config(Sensor, port2,  armBump,        sensorVexIQ_Touch)
#pragma config(Sensor, port11, storageUpBump,  sensorVexIQ_Touch)
#pragma config(Sensor, port12, storageDownBump, sensorVexIQ_Touch)
#pragma config(Motor,  motor1,          rightDrive,    tmotorVexIQ, PIDControl, driveRight, encoder)
#pragma config(Motor,  motor4,          armMotor,      tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor5,          clawMotor,     tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor6,          leftDrive,     tmotorVexIQ, PIDControl, reversed, driveLeft, encoder)
#pragma config(Motor,  motor7,          storageMotor,  tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor8,          intakeMotor,   tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor10,         intakeMotor,   tmotorNone, openLoop)
#pragma config(Motor,  motor11,         storageMotor,  tmotorNone, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Threshold to keep robot from drifting from joystick value errors
int joystickThreshold = 10;

// scale the joystick range (-127 to 127) to motor range ( -100 to 100)
int scaleJoystickToMotor(int joystickValue){
	// Add an offset to account for drift
	int offsetValue = abs(joystickValue) - joystickThreshold ;
	// Add a minimum so drift compensation does not reverse direction
	if (offsetValue <= 0)
		return 0;
	// Scale the value
	int scaledValue = round(offsetValue / ((127 - joystickThreshold) / 100));
	return scaledValue;
}

task driveControl(){
	while(true){
		// Variables
		int leftJoystickPolarity = 1;
		int rightJoystickPolarity = 1;
		int leftJoystickValue = getJoystickValue(ChA);
		int rightJoystickValue = getJoystickValue(ChD);
		// Determine direction of the joystick
		if (leftJoystickValue < 0)
			leftJoystickPolarity = -1;
		if (rightJoystickValue < 0)
			rightJoystickPolarity = -1;
		// Calculate the speed and direction of the motor by multiplying
		// the polarity (1 or -1) by the scaled joystick value (from scaleJoystickToMotor)
		int scaledLeftJoystickValue = scaleJoystickToMotor(leftJoystickValue) * leftJoystickPolarity;
		int scaledRightJoystickValue = scaleJoystickToMotor(rightJoystickValue) * rightJoystickPolarity;
		// Set motor to the scaled joystick values with the correct directions
		setMotor(leftDrive, scaledLeftJoystickValue);
		setMotor(rightDrive, scaledRightJoystickValue);
		// Delay to not overload brain
		sleep(100);
	}
}


task intakeControl(){
	while(true){
		// If both L Buttons are pressed, run contantly
		if(vexRT[BtnLUp] == true && vexRT[BtnLDown] == true){
			setMotor(intakeMotor, 100);
			// Add delay to provide time to register next L Button press
			sleep(200);
			// If either L Button is pressed individually, exit constant spin
			// and switch to armControl
			waitUntil(vexRT[BtnLUp] == true || vexRT[BtnLDown] == true);
		}
		// If not running constantly, use armControl
		else{
			armControl(intakeMotor, BtnLDown, BtnLUp);
		}
	}
}

task storageControl(){
	while(true){
		// If E-Up Button is pressed and storage is not at max height
		// (if storageUp bumper is pressed) then move storage up
		if(vexRT[BtnEUp] == true && getBumperValue(storageUpBump) == false){
			setMotor(storageMotor, 100);
		}
		// If E-Down Button is pressed and storage is not fully lowered
		// (if storageDown bumper is pressed) then move storage down
		else if(vexRT[BtnEDown] == true && getBumperValue(storageDownBump) == false){
			setMotor(storageMotor, -100);
		}
		// If neither is true, hold motor
		else{
			stopMotor(storageMotor);
		}
	}
}


task mainControl(){
	while(true){
		// Arm Controls
		// Move arm up if R-Up Button pressed
		if(vexRT[BtnRUp] == true){
			setMotor(armMotor, -100);
		}
		// Move arm down if R-Down Button pressed
		// and arm is not down all the way (if bumper is pressed)
		else if(vexRT[BtnRDown] == true && getBumperValue(armBump) == false){
			setMotor(armMotor, 100);
		}
		// Hold motor if neither are true
		else{
			stopMotor(armMotor);
		}
		// Claw Controls
		armControl(clawMotor, BtnFUp, BtnFDown);
	}
}

task main(){
	// Start the tasks
	startTask(driveControl);
	startTask(intakeControl);
	startTask(mainControl);
	startTask(storageControl);
	// Display text to screen
	// Loop to keep program running
	while(true){
		displayTextLine(1, "Asian Teleop");

	}
}
